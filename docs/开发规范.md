## 基本开发准则

1. 所有对外接口统一通过say-hi-gateway模块提供，系统对外提供的能力只能通过gateway对外暴露，各业务模块提供对外的RPC接口，gateway来调用这些接口
2. 微服务间通信使用gRPC，定义在say-hi-sdk模块中
3. gateway的实体类直接通过Java对象定义，其他微服务模块内部数据流转的对象尽量通过protobuf来定义，数据模型需要在gateway和各微服务间保持一致
4. WebSocket长连接由gateway模块维护
5. 权限验证使用Sa-Token框架
6. API文档使用Knife4j生成
7. 新增的Java对象以及新增的Java方法需要有明确的头注释，便于后序AI程序理解
8. 一些判断方法尽量使用org.apache.commons.lang3下的Utils工具类，比如StringUtils、
9. RPC返回异常的时候需要在RPC的response中添加错误码、异常信息，不要直接抛出异常。错误码需要使用say-hi-sdk中error_code.proto的错误码定义
10. 业务内部逻辑尽量不要抛出异常，可以用null来代替非预期情况
11. 操作DB的行为尽可能直接使用mybatis-plus，不需要实现具体的mapper.xml，借助mybatis plus，直接在Service层完成对数据基本的增删改查
12. RPC接口协议需要以xxRequest、xxResponse格式命名，比如SendMessageRequest、SendMessageResponse
13. 每次新增完代码都要重新编译整个项目，确保项目能编译通过
14. RPC新增的方法具体业务逻辑下沉到Service层，不要直接在RPC的实现类中实现
15. 各业务领域新增的RPC方法，需要在common包中封装为对应的stub类方法，这样其他所有的包都可以使用该方法了
16. 必须使用@Resource引用Bean依赖


## 如何开发一个RPC接口？

1. 阅读SDK中对应的proto文件，若没有相关接口定义则手动定义该接口，定义该接口的时候需要思考最常见的业务场景的入参格式，同时参考库表结构，避免不符合分库分表规则（库表结构我后序再补充）
2. 在对应的微服务模块的RPC文件夹的RPC实现类中实现对应接口
3. 补充并完善Service层、Mapper层接口逻辑，以供上层RPC实现接口调用
4. 重新编译SDK模块，避免IDE无法直接识别新增的proto对象

注意：RPC实现类需要满足以下模板，且不要在RPC实现类中掺杂过多业务逻辑，具体业务逻辑请下沉到Service层

```java
@Override
public void sendMessage(SendMessageRequest request, StreamObserver<SendMessageResponse> responseObserver) {
        String invokeName = "ChatToBCsGrpcService.sendMessage";
        // 参数判断
        Consumer<SendMessageRequest> checkParams = req -> {
        checkArgument(req.getUserId() > 0, "invalid userId");
        };

        ProcessFunc<SendMessageRequest, SendMessageResponse> processFunc = req -> {
        return messageService.sendMessage(req);
        };

        GrpcTemplate.execute(invokeName, request, checkParams, processFunc,
        getResponseProcess(SendMessageResponse.class), responseObserver);
        }
```

## 如何操作 Redis？

代码里直接引用 Spring 提供的 RedisTemplate 即可